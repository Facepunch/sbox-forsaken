@using System;
@using Sandbox;
@using Sandbox.UI;
@using Sandbox.UI.Construct;
@using Facepunch.Forsaken;
@using System.IO;

@namespace Facepunch.Forsaken.UI
@attribute [StyleSheet( "/ui/Map.scss" )]
@inherits Panel
@implements IDialog

@if ( !ForsakenPlayer.Me.IsValid() ) return;

<root>
    <div @ref="Viewport" class="viewport">
        <div @ref="Container" class="map">
            <div @ref="Grid" class="grid"></div>
            <img @ref="Drawing" class="drawing" />
        </div>
    </div>
</root>

@code
{
    public static Map Current { get; private set; }

    public bool AllowMovement => true;
    public bool IsOpen { get; private set; }

    private Panel Viewport { get; set; }
    private Panel Container { get; set; }
    private Panel Player { get; set; }
    private Image Drawing { get; set; }
    private Panel Grid { get; set; }
    private bool IsDrawing { get; set; }
    private bool IsPanning { get; set; }
    private Vector2 LastMousePosition { get; set; }
    private TimeUntil NextSaveMap { get; set; }
    private Vector2 Position { get; set; }

    public void Open()
    {
        if ( IsOpen ) return;
        Dialog.Activate( this );
        IsOpen = true;
    }

    public void Close()
    {
        if ( !IsOpen ) return;
        Dialog.Deactivate( this );
        IsOpen = false;
    }

    public override void Tick()
    {
        if ( Drawing is null ) return;
        if ( Player is null ) return;

        Drawing.Texture = Map.CreateTexture();

        var localPlayer = ForsakenPlayer.Me;
        if ( !localPlayer.IsValid() ) return;

        var mapBounds = new Vector2( 7000f, 7000f );
        var position = new Vector2( localPlayer.Position );

        position.x += mapBounds.x * 0.5f;
        position.y += mapBounds.y * 0.5f;

        var fx = position.x / mapBounds.x;
        var fy = position.y / mapBounds.y;

        var rotation = localPlayer.Rotation.Inverse.Yaw();

        var tx = new PanelTransform();
        tx.AddTranslateX( Length.Fraction( -0.5f ) );
        tx.AddTranslateY( Length.Fraction( -0.5f ) );
        tx.AddRotation( 0f, 0f, rotation + 90f );

        Player.Style.Transform = tx;
        Player.Style.Left = Length.Fraction( fx );
        Player.Style.Top = Length.Fraction( 1f - fy );

        base.Tick();
    }

    protected override void OnMouseMove( MousePanelEvent e )
    {
        if ( IsPanning )
        {
            var cx = Container.Style.Left.GetValueOrDefault( 0f );
            var cy = Container.Style.Top.GetValueOrDefault( 0f );

            var nx = (cx.Value * ScaleToScreen) + Mouse.Delta.x * 2f;
            var ny = (cy.Value * ScaleToScreen) + Mouse.Delta.y * 2f;

            nx = Math.Min( nx, 0f );
            ny = Math.Min( ny, 0f );

            var vp = Viewport.Box.Rect;
            var vw = vp.Width;
            var vh = vp.Height;

            var cp = Container.Box.Rect;
            var dw = cp.Width - vw;
            var dh = cp.Height - vh;

            nx = Math.Max( nx, -dw );
            ny = Math.Max( ny, -dh );

            Position = new Vector2( nx / cp.Width, ny / cp.Height );

            UpdatePosition();
        }

        base.OnMouseMove( e );
    }

    protected override void OnMouseDown( MousePanelEvent e )
    {
        if ( e.Button == "mouseleft" )
        {
            LastMousePosition = Mouse.Position;
            IsDrawing = true;
        }

        if ( e.Button == "mouseright" )
        {
            IsPanning = true;
        }

        base.OnMouseDown( e );
    }

    protected override void OnMouseUp( MousePanelEvent e )
    {
        if ( e.Button == "mouseleft")
        {
            IsDrawing = false;
        }

        if ( e.Button == "mouseright" )
        {
            IsPanning = false;
        }

        base.OnMouseUp( e );
    }

    protected override void OnParametersSet()
    {
        BindClass( "is-panning", () => IsPanning );
        BindClass( "is-drawing", () => IsDrawing );
        BindClass( "hidden", () => !IsOpen );
        Current = this;

        base.OnParametersSet();
    }

    protected override void OnAfterTreeRender( bool firstTime )
    {
        Drawing.Texture = Map.CreateTexture();

        CreatePlayerMarker();
        UpdatePosition();
        PopulateGrid();

        base.OnAfterTreeRender( firstTime );
    }

    protected override int BuildHash()
    {
        return HashCode.Combine( ForsakenPlayer.Me );
    }

    [Event.Tick.Client]
    private void ClientTick()
    {
        if ( string.IsNullOrEmpty( ForsakenGame.UniqueSaveId ) ) return;
        if ( Drawing?.Texture is null ) return;
        if ( !NextSaveMap ) return;

        var fileName = $"maps/{ForsakenGame.UniqueSaveId}.map";

        FileSystem.Data.CreateDirectory( $"maps" );

        using ( var writer = FileSystem.Data.OpenWrite( fileName, FileMode.Create ) )
        {
            writer.Write( Compress( Map.Data ) );
        }

        NextSaveMap = 10f;
    }

    private void PopulateGrid()
    {
        Grid.DeleteChildren( true );

        var cp = Container.Box.Rect;

        for ( var x = 0; x < 10; x++ )
        {
            for ( var y = 0; y < 10; y++ )
            {
                var squareSize = cp.Width / 10f;
                var square = Grid.AddChild<Panel>( "square" );
                square.Style.Left = Length.Pixels( (squareSize * x * ScaleFromScreen) );
                square.Style.Top = Length.Pixels( (squareSize * y * ScaleFromScreen) );
                square.Add.Label( $"{x},{y}", "coord" );
            }
        }
    }

    private void UpdatePosition()
    {
        var cp = Container.Box.Rect;
        Container.Style.Left = Length.Pixels( cp.Width * Position.x * ScaleFromScreen );
        Container.Style.Top = Length.Pixels( cp.Height * Position.y * ScaleFromScreen );
    }

    private void CreatePlayerMarker()
    {
        Player?.Delete( true );
        Player = Container.AddChild<Panel>( "player" );
    }

    [Event.Client.Frame]
    private void OnFrame()
    {
        if ( !IsVisible || Container is null ) return;

        UpdatePosition();

        if ( !IsDrawing ) return;

        var box = Drawing.Box.Rect;

        var start = LastMousePosition;
        var end = Mouse.Position;
        var points = new Vector2[10];

        for ( var i = 0; i < 10; i++ )
        {
            points[i].x = ((start.x - end.x) / 10f) * i + end.x;
            points[i].y = ((start.y - end.y) / 10f) * i + end.y;
        }

        foreach ( var point in points )
        {
            if ( box.IsInside( point ) )
            {
                var rx = (point.x - box.Left) * (Map.Texture.Width / box.Width);
                var ry = (point.y - box.Top) * (Map.Texture.Height / box.Height);
                var x = rx.CeilToInt().Clamp( 0, Map.Texture.Width - 1 );
                var y = ry.CeilToInt().Clamp( 0, Map.Texture.Height - 1 );

                Map.Draw( x, y, 2f, Color.Red );
            }
        }

        LastMousePosition = Mouse.Position;
    }
}
